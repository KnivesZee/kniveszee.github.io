<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta name="baidu-site-verification" content="UqlC4pwKIm">
  <meta name="baidu-site-verification" content="d3U0dGeqGw">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="1C1XSuJ8TgM2O0mcZvsgzEdy0IdRZOJfxDYPyh18U9Q">














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.cat.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="language,">










<meta name="description" content="做个笔记简要记录一下C++11部分特性：） 一、 C++11的新功能1.1 新类型C++11增加long long和unsigned long以支持64位（或更宽）的整型，新增char16_t，char32_t以支持16位和32位的字符表示。 1.2 初始化列表语法C++11扩大了大括号括起的列表的适用范围，使其可以用于所有内置类型和自定义类对象。同时使用初始化列表时，可添加等号也可不添加等号，如">
<meta name="keywords" content="language">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11 New Feature">
<meta property="og:url" content="http://knivezee.site/2019/07/18/2019-07-18-Talk-About-C-11-md/index.html">
<meta property="og:site_name" content="拾碎集">
<meta property="og:description" content="做个笔记简要记录一下C++11部分特性：） 一、 C++11的新功能1.1 新类型C++11增加long long和unsigned long以支持64位（或更宽）的整型，新增char16_t，char32_t以支持16位和32位的字符表示。 1.2 初始化列表语法C++11扩大了大括号括起的列表的适用范围，使其可以用于所有内置类型和自定义类对象。同时使用初始化列表时，可添加等号也可不添加等号，如">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-18T08:42:57.457Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++11 New Feature">
<meta name="twitter:description" content="做个笔记简要记录一下C++11部分特性：） 一、 C++11的新功能1.1 新类型C++11增加long long和unsigned long以支持64位（或更宽）的整型，新增char16_t，char32_t以支持16位和32位的字符表示。 1.2 初始化列表语法C++11扩大了大括号括起的列表的适用范围，使其可以用于所有内置类型和自定义类对象。同时使用初始化列表时，可添加等号也可不添加等号，如">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://knivezee.site/2019/07/18/2019-07-18-Talk-About-C-11-md/">





  <title>C++11 New Feature | 拾碎集</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-111723881-1', 'auto');
  ga('send', 'pageview');
</script>






  <style>
 	.forkme{
 		display: none;
	}
	@media (min-width: 768px) {
 		.forkme{
 			display: inline;
 		}
  	}
  </style>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <!-- github小猫 start -->
<!--     <a href="https://github.com/KnivesZee" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style> -->
	
	<div class="forkme">
	<a href="https://github.com/KnivesZee" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>
	</div>
    <!-- github小猫 end -->
    
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">拾碎集</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://knivezee.site/2019/07/18/2019-07-18-Talk-About-C-11-md/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Knives">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://pj5mfieap.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="拾碎集">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">C++11 New Feature</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-18T16:38:36+08:00">
                2019-07-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2019-07-18T16:42:57+08:00">
                2019-07-18
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/07/18/2019-07-18-Talk-About-C-11-md/" class="leancloud_visitors" data-flag-title="C++11 New Feature">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  5,526
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>做个笔记简要记录一下C++11部分特性：）</p>
<h2 id="一、-C-11的新功能"><a href="#一、-C-11的新功能" class="headerlink" title="一、 C++11的新功能"></a>一、 C++11的新功能</h2><h3 id="1-1-新类型"><a href="#1-1-新类型" class="headerlink" title="1.1 新类型"></a>1.1 新类型</h3><p>C++11增加<code>long long</code>和<code>unsigned long</code>以支持64位（或更宽）的整型，新增<code>char16_t</code>，<code>char32_t</code>以支持16位和32位的字符表示。</p>
<h3 id="1-2-初始化列表语法"><a href="#1-2-初始化列表语法" class="headerlink" title="1.2 初始化列表语法"></a>1.2 初始化列表语法</h3><p>C++11扩大了大括号括起的列表的适用范围，使其可以用于所有内置类型和自定义类对象。同时使用初始化列表时，可添加等号也可不添加等号，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = &#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> y &#123;<span class="number">2.74l</span>&#125;;</span><br><span class="line"><span class="keyword">short</span> arr[<span class="number">5</span>] &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">YourObj <span class="title">s1</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>; <span class="comment">// old style</span></span><br><span class="line">YourObj s2&#123;<span class="number">1</span>, <span class="number">3</span>&#125;; <span class="comment">// C++11</span></span><br><span class="line">YourObj s3 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;; <span class="comment">// C++11</span></span><br></pre></td></tr></table></figure>
<p>需要注意的时若类有将模板<code>std::initializer_list</code>作为参数的构造函数，则只有该构造函数可以使用列表初始化形式。</p>
<p><strong>初始化列表的好处：</strong></p>
<p>初始化列表语法可防止缩窄（将数值赋值给无法存储它的数值变量），编译器将禁止如下类型的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c &#123;<span class="number">1.53e27</span>&#125;; <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>
<p>但允许转换为更宽的类型，此外，如果值在较窄类型的取值范围内，将其转换为较窄的类型也是允许的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1&#123;<span class="number">55</span>&#125;; <span class="comment">// allow</span></span><br><span class="line"><span class="keyword">double</span> c2 = &#123;<span class="number">66</span>&#125;; <span class="comment">// allow</span></span><br></pre></td></tr></table></figure>
<p><strong>std::initializer_list</strong></p>
<p>C++11提供了模板类initializer_list，可将其用作构造函数的参数，如果类有接受initializer_list作为参数的构造函数，则初始化列表语法就只能用于该构造函数。列表的元素必须时同一种类型/可转为同一种类型。STL容器也提供了将initializer_list作为参数的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1(<span class="number">10</span>); <span class="comment">// vector with 10 elements</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2&#123;<span class="number">10</span>&#125;; <span class="comment">// vector with 1 elements set to 10</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a3&#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>&#125;; <span class="comment">// 3 elements set to 4, 6, 1</span></span><br></pre></td></tr></table></figure>
<p>除了用于构造函数外，还可以将initializer_list用作常规函数的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; il)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : il) &#123;</span><br><span class="line">        tot += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = sum(&#123;<span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">4</span>&#125;); <span class="comment">// 4 converted to 4.0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-声明"><a href="#1-3-声明" class="headerlink" title="1.3 声明"></a>1.3 声明</h3><p>C++11提供了多种简化声明的功能，尤其在使用模板时：</p>
<ul>
<li>auto</li>
<li>decltype： 将变量的类型声名为表达式指定的类型</li>
<li>返回类型后置：在函数名和参数列表后面指定返回类型</li>
<li>模板别名： using =</li>
<li>nullptr</li>
</ul>
<p><strong>关键字decltype的个示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">decltype</span>(x) y;</span><br></pre></td></tr></table></figure>
<p><strong>返回类型后置的示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">auto f2(double, int) -&gt; double;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">f3</span>(<span class="title">T</span>, <span class="title">U</span>) -&gt; <span class="title">decltype</span>(<span class="title">T</span> * <span class="title">U</span>);</span></span><br></pre></td></tr></table></figure>
<p>上面最后一个例子，当编译器遇到f3参数列表之前，T和U还不在作用域内，因此必须在参数列表后使用decltype。</p>
<p><strong>模板别名示例</strong></p>
<p>C++之前版本会这么做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator itType;</span><br></pre></td></tr></table></figure>
<p>使用新语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> itType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator;</span><br></pre></td></tr></table></figure>
<p>差别在于，新语法也可用于模板部分具体化，但typedef不能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">using</span> arr12 = <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, <span class="number">12</span>&gt;;</span><br><span class="line"></span><br><span class="line">arr12&lt;<span class="built_in">string</span>&gt; a2;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-智能指针"><a href="#1-4-智能指针" class="headerlink" title="1.4 智能指针"></a>1.4 智能指针</h3><p>C++11抛弃了auto_ptr，并新增三种智能指针：</p>
<ul>
<li>unique_ptr</li>
<li>shared_ptr</li>
<li>weak_ptr</li>
</ul>
<p>unique_ptr如何能够区分安全和不安全的用法？——使用了C++11新增的移动构造函数和右值引用</p>
<h3 id="1-5-异常规范修改"><a href="#1-5-异常规范修改" class="headerlink" title="1.5 异常规范修改"></a>1.5 异常规范修改</h3><p>添加关键字noexcept</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>, <span class="keyword">short</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// doesn't throw an exception</span></span><br></pre></td></tr></table></figure>
<h3 id="1-6-对类的修改"><a href="#1-6-对类的修改" class="headerlink" title="1.6 对类的修改"></a>1.6 对类的修改</h3><h4 id="1-6-1-显示转换运算符"><a href="#1-6-1-显示转换运算符" class="headerlink" title="1.6.1 显示转换运算符"></a>1.6.1 显示转换运算符</h4><p>C++11引入关键字explicit以禁止单参数构造函数导致的自动转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plebe</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Plebe(<span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Plebe</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Plebe a, b;</span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line">b = <span class="number">0.5</span>;			<span class="comment">// not allowed</span></span><br><span class="line">b = Plebe(<span class="number">0.5</span>); 	<span class="comment">// explicit conversion</span></span><br></pre></td></tr></table></figure>
<p>C++11扩展了explict的这种用法，使得可对转换函数做类似的处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plebe</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// conversion functions</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Plebe a, b;</span><br><span class="line"><span class="keyword">int</span> n = a;		<span class="comment">// automatic conversion</span></span><br><span class="line"><span class="keyword">double</span> x = b;	<span class="comment">// not allowed</span></span><br><span class="line">x = <span class="keyword">double</span>(b);	<span class="comment">// explict conversion, allowed</span></span><br></pre></td></tr></table></figure>
<h4 id="1-6-2-类内成员初始化"><a href="#1-6-2-类内成员初始化" class="headerlink" title="1.6.2 类内成员初始化"></a>1.6.2 类内成员初始化</h4><p>C++11允许类内成员定义时初始化一个默认值</p>
<h3 id="1-7-模板和STL方面的修改"><a href="#1-7-模板和STL方面的修改" class="headerlink" title="1.7 模板和STL方面的修改"></a>1.7 模板和STL方面的修改</h3><p>为改善模板和标准模板库的可用性，C++11做了多个改进：</p>
<ul>
<li>增强for循环</li>
<li>新的STL容器：foward_list(单向链表)、unordered_map、unordered_multimap、unordered_set、unordered_multiset</li>
<li>新的模板： array（定长数组，没resize,push_back等方法，但有begin(), end()方法）</li>
<li>新的STL算法：cbegin(), cend()等const版本（将元素视为const）</li>
<li>摒弃export： 但保留了该关键字</li>
<li>尖括号：为避免与&gt;&gt;混淆，C++之前会要求嵌套声明模板时用空格将尖括号分开，C++11不再这样要求</li>
<li>右值引用： &amp;&amp; ，将右值关联到右值引用导致该右值被存储到特定的位置，且可获取该位置的地址。</li>
<li>移动语义（下面讨论）</li>
<li>SFINEA</li>
</ul>
<p>这里着重说明一下SFINEA：</p>
<p>SFINAE(substitution failure is not a error) 主要用于模板函数，它是指，编译器在使用具体类型来替换模板类型参数，对模板进行实例化（展开模板）时，如果发生替换失败，那么并不会直接引发编译错误（Error），而只是简单地把这个模板从重载候选者中去除掉。</p>
<p>在 <a href="http://www.martinecker.com/wiki/index.php?title=SFINAE_Principle" title="http://www.martinecker.com/wiki/index.php?title=SFINAE_Principle" target="_blank" rel="noopener">http://www.martinecker.com/wiki/index.php?title=SFINAE_Principle</a> 有这么一段：</p>
<blockquote>
<p>To summarize, the essence of the SFINAE principle is this: <strong>If an invalid argument or return type is formed when a function template is instantiated during overload resolution, the function template instantiation is removed from the overload resolution set and does not result in a compilation error.</strong></p>
</blockquote>
<p>就是说，SFINAE 原则的本质就是：<strong>当进行重载决议时，如果函数模板实例化后产生了无效的参数类型或是返回类型，那么这个实例化会从重载选项是去除掉，但不产生编译错误。</strong></p>
<p>这句话讲得很到位。要把握两点：</p>
<p>1、SFINAE 是在重载决议时起作用的。<br>2、SFINAE 起作用时是因为产生了无效的参数类型或返回值类型，注意，<strong>这个类型可以是返回值的类型</strong>！（这点很重要，因为有时候你不能在参数列表上做动作，比如重载运算符的时候，编译器对参数的多少是有限定的）</p>
<h2 id="二、-移动语义和右值引用"><a href="#二、-移动语义和右值引用" class="headerlink" title="二、 移动语义和右值引用"></a>二、 移动语义和右值引用</h2><h3 id="2-1-为什么需要移动语义"><a href="#2-1-为什么需要移动语义" class="headerlink" title="2.1 为什么需要移动语义"></a>2.1 为什么需要移动语义</h3><p>先看看C++11之前的复制过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr;</span><br><span class="line"><span class="comment">// build up a vector of 20,000 strings, each of 1000 characters</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr_copy(vstr);</span><br></pre></td></tr></table></figure>
<p>由于vector和string都使用动态内存分配，因此他们必须定义使用某种new版本的复制构造函数。为初始化对象<code>vstr_copy</code>，<code>vector&lt;string&gt;</code>的复制构造函数将使用new给2W个<code>string</code>对象分配内存，而每个<code>string</code>对象又要调用string的复制构造函数，该构造函数使用new为1000个字符分配内存。接下来全部2000W个字符都将从<code>vstr</code>的内存中复制到<code>vstr_copy</code>的内存中，工作量非常大。</p>
<p>这样妥当吗？有时候的答案是否定的，假设有个allcaps函数，它返回一个函数内构造的<code>vector&lt;string&gt;</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr;</span><br><span class="line"><span class="comment">// build up a vector of 20,000 strings, each of 1000 characters</span></span><br><span class="line">   ...</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr_copy1(vstr);			<span class="comment">// #1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vstr_copy2(allcaps(vstr));	<span class="comment">// #2</span></span><br></pre></td></tr></table></figure>
<p>表面上看#1和#2类似，他们都使用一个现有的对象初始化一个<code>vector&lt;string&gt;</code>对象。但是<code>allcaps()</code>创建了一个临时的<code>vector&lt;string&gt;</code>对象temp并将之返回，该对象管理者2000W个字符，迟钝的编译器可能会将temp赋值给一个临时返回对象，删除temp，再删除临时返回对象。这样会做大量无用功。考虑到临时对象被删除了，如果编译器将temp对数据的所有权直接转让给vstr_copy2不更好吗？<strong>也就是说这种类似于计算机中移动文件的情形：实际文件还保留再原来的地方，而只是修改记录，这种方法被称为移动语义</strong>（move semantics）。</p>
<p>要实现移动语义，需要采用某种方式让编译器知道什么时候需要复制，什么时候不需要。这就是右值发挥作用的地方。即——定义两个构造函数，一个是原来的构造函数，它使用const左值引用作为参数，这个引用关联到左值实参，如语句#1中的vstr；另一个是移动构造函数，它使用右值引用作为参数，该引用关联到右值实参，如语句#2中的allcaps(vstr)的返回值。</p>
<p>这一点类似与其他语言中的深拷贝和浅拷贝。普通构造函数是深拷贝，而移动构造函数只调整记录。在将所有权转移给新对象的过程中，移动构造函数会修改其实参，这意味着右值引用参数不应该是const。</p>
<h3 id="2-2-移动构造函数解析"><a href="#2-2-移动构造函数解析" class="headerlink" title="2.2 移动构造函数解析"></a>2.2 移动构造函数解析</h3><p>虽然右值可支持移动语义，但这并不会神奇的发生。要让移动语义繁盛，需要两个步骤：首先右值引用让编译器知道何时使用移动语义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Useless two = one;			<span class="comment">// matches Useless::Useless(const Useless &amp;)</span></span><br><span class="line"><span class="function">Useless <span class="title">four</span><span class="params">(one + three)</span></span>;	<span class="comment">// matches Useless::Useless(Useless &amp;&amp;)</span></span><br></pre></td></tr></table></figure>
<p>对象one是左值，与左值引用匹配，而表达式one+three是右值，与右值引用匹配。因此，右值引用让编译器使用移动构造函数来初始化对象four。实现移动语义的第二步是：编写移动构造函数，使其提供所需的行为</p>
<h3 id="2-3-赋值"><a href="#2-3-赋值" class="headerlink" title="2.3 赋值"></a>2.3 赋值</h3><p>适用于构造函数的移动语义也适用于赋值运算符。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Useless</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span>* pc;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ct;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Useless &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Useless &amp;);</span><br><span class="line">    Useless &amp; <span class="keyword">operator</span>=(Useless &amp;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Useless &amp; Useless::<span class="keyword">operator</span>=(<span class="keyword">const</span> Useless &amp; f) &#123; <span class="comment">// copy assignment</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    n = f.n;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless &amp; Useless::<span class="keyword">operator</span>=(Useless &amp;&amp; f) &#123;	<span class="comment">// move assignment</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    n = f.n;</span><br><span class="line">    pc = f.pc;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能让多个指针指向相同的数据，这很重要，因此上述代码将源对象中的指针设置为空指针。与移动构造函数一样，移动赋值运算符的参数也不能是const引用，因为这个方法修改了源对象。</p>
<h3 id="2-4-强制移动"><a href="#2-4-强制移动" class="headerlink" title="2.4 强制移动"></a>2.4 强制移动</h3><p>如果在下面这种情况中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Useless choces[<span class="number">10</span>];</span><br><span class="line">Useless best;</span><br><span class="line"><span class="keyword">int</span> pick = <span class="number">4</span>;</span><br><span class="line">best = choces[pick];</span><br></pre></td></tr></table></figure>
<p>如果可以在选择了best以后，将pick指向的Useless对象元素从原数组中删除该多好，但是choces[pick]是一个左值，上述赋值语句将使用赋值运算符，而不是移动赋值运算符。但可以使用<code>static_cast&lt;&gt;</code>将对象的类型强制转换为Useless &amp;&amp;，此外C++11也提供了一种更简单的方式<code>std::move()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Useless choces[<span class="number">10</span>];</span><br><span class="line">Useless best;</span><br><span class="line"><span class="keyword">int</span> pick = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// way 1</span></span><br><span class="line">best = <span class="keyword">static_cast</span>&lt;Useless &amp;&amp;&gt;(choces[pick]);</span><br><span class="line"><span class="comment">// way 2</span></span><br><span class="line">best = <span class="built_in">std</span>::move(choces[pick]);</span><br></pre></td></tr></table></figure>
<p>但是需要主义的是，<code>std::move()</code>并非一定会导致移动操作。例如，假设Chunk是一个包含私有数据的类，而使用了如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chunk one;</span><br><span class="line">...</span><br><span class="line">Chunk two;</span><br><span class="line">two = <span class="built_in">std</span>::move(one);</span><br></pre></td></tr></table></figure>
<p>表达式std::move(one)是右值，因此伤处赋值语句调用Chunk的移动赋值运算符——如果定义了这样的运算符。如果Chunk没有定义移动赋值运算符，编译器将使用复制赋值运算符。如果也没有定义复制赋值运算符，将根本不允许上述赋值。</p>
<p>对于我们来说，右值引用带来的主要好处并非是让我们能够编写使用右值引用的代码，而是能够使用利用右值引用实现移动语义的库代码。如STL类现在都有复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符。</p>
<h3 id="2-5-std-move-原理"><a href="#2-5-std-move-原理" class="headerlink" title="2.5 std::move() 原理"></a>2.5 std::move() 原理</h3><p>std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast&lt;T&amp;&amp;&gt;(lvalue);</p>
<p>函数参数T&amp;&amp;是一个指向模板类型参数的右值引用，通过引用折叠，此参数可以与任何类型的实参匹配（可以传递左值或右值，这是std::move主要使用的两种场景)。关于引用折叠如下：</p>
<ul>
<li>1、X&amp; &amp;、X&amp;&amp; &amp;、X&amp; &amp;&amp;都折叠成X&amp;，用于处理左值</li>
<li>2、X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;，用于处理右值</li>
</ul>
<p>简单来说，右值经过T&amp;&amp;传递类型保持不变还是右值，而左值经过T&amp;&amp;变为普通的左值引用。对于static_cast&lt;&gt;的使用注意：任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast。</p>
<p>std::move实现，首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过T&amp;&amp;传递类型保持不变还是右值，而左值经过T&amp;&amp;变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。然后我们通过static_cast&lt;&gt;进行强制类型转换返回T&amp;&amp;右值引用，而static_cast<t>之所以能使用类型转换，是通过remove_refrence<t>::type模板移除T&amp;&amp;，T&amp;的引用，获取具体类型T。</t></t></p>
<h2 id="三、-新的类功能"><a href="#三、-新的类功能" class="headerlink" title="三、 新的类功能"></a>三、 新的类功能</h2><h3 id="3-1-特殊的成员函数"><a href="#3-1-特殊的成员函数" class="headerlink" title="3.1 特殊的成员函数"></a>3.1 特殊的成员函数</h3><p>在原有4个特殊成员函数（默认构造函数，赋值构造函数，复制赋值运算符和析构函数）的基础上C++新增了两个：</p>
<ul>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
</ul>
<p>在没有提供任何参数的情况下，将调用默认构造函数。如果没有给类显示的定义任何构造函数，编译器将提供一个默认构造函数。这种版本的默认构造函数被称为默认的默认构造函数。对于使用内置类型的成员，默认的默认构造函数不对其进行初始化；对于属于类对象的成员，则调用其默认构造函数。</p>
<p>此外，如果没有提供复制构造函数，而代码又需要它，编译器将提供一个默认的复制构造函数，如果没有提供移动复制构造函数，而代码又需要它，编译器将提供一个默认的移动构造函数。默认的移动构造函数和移动赋值运算符的工作方式与复制版本类似：执行逐成员初始化并复制内置类型。如果成员是类对象，将使用相应类的构造函数和赋值运算符，就像参数为右值一样。如果定义了移动构造函数和移动赋值运算符，这将调用他们；否则将调用复制构造函数和复制赋值运算符。</p>
<p>最后，如果没有提供析构函数，编译器也将默认提供一个。</p>
<p>对于上面描述的情况，有一些例外：</p>
<ul>
<li>如果定义了析构函数，复制构造函数或复制赋值运算符，编译器将不会自动提供移动构造函数和移动赋值运算符</li>
<li>如果定义了移动构造函数或移动赋值运算符，编译器将不会自动提供复制构造函数和复制赋值运算符</li>
</ul>
<h3 id="3-2-默认的方法和禁用的方法"><a href="#3-2-默认的方法和禁用的方法" class="headerlink" title="3.2 默认的方法和禁用的方法"></a>3.2 默认的方法和禁用的方法</h3><p>假如你要使用某个默认的函数 ，而这个函数出于某种原因不会自动创建。（定义了移动构造函数，因此编译器不会自动创建默认的构造函数，复制构造函数和复制赋值构造函数）在这些情况下，可使用default显式地声明这些方法的默认版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SomeClass(SomeClass &amp;&amp;);</span><br><span class="line">    SomeClass() = <span class="keyword">default</span>;</span><br><span class="line">    SomeClass(<span class="keyword">const</span> SomeClass &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    SomeClass &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SomeClass &amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一方面，关键字delete可用于禁止编译器使用特定方法，例如，要禁止复制对象，可禁用复制构造函数和复制赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SomeClass() = <span class="keyword">default</span>;</span><br><span class="line">    SomeClass(<span class="keyword">const</span> SomeClass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SomeClass &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SomeClass &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SomeClass(SomeClass &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    SomeClass &amp; <span class="keyword">operator</span>=(SomeClass &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    SomeClass &amp; <span class="keyword">operator</span>+(<span class="keyword">const</span> SomeClass &amp;) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键字default只能用于6个特殊成员函数，但delete可用于任何成员函数。delete的一种可能用法是禁止特定的转换，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redo</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种情况下，方法调用sc.redo(4)与原型redo(int)匹配。编译器检测到这一点以及redo(int)被禁用后，将这种调用视为编译错误。这也说明了禁用函数的重要一点：他们只用于查找匹配函数，使用他们将导致编译错误。</p>
<h3 id="3-3-委托构造函数"><a href="#3-3-委托构造函数" class="headerlink" title="3.3 委托构造函数"></a>3.3 委托构造函数</h3><p>C++11允许在一个构造函数的定义中使用另一个构造函数，这被称为委托，因为构造函数暂时将创建对象的工作委托给另一个构造函数。</p>
<h3 id="3-4-继承构造函数，override和final"><a href="#3-4-继承构造函数，override和final" class="headerlink" title="3.4 继承构造函数，override和final"></a>3.4 继承构造函数，override和final</h3><p>为简化编码工作，C++11提供了一种让派生类能够继承基类构造函数的机制。</p>
<p>C++11中可使用override指出要覆盖的一个虚函数，将其放在参数列表后面。如果声明与基类方法不匹配，编译器将视为错误。final禁止派生类覆盖特定的虚方法。</p>
<h2 id="四、Lamdba"><a href="#四、Lamdba" class="headerlink" title="四、Lamdba"></a>四、Lamdba</h2><p>Lamdba的一个示例如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&amp;count](<span class="keyword">int</span> x) &#123;count += (x % <span class="number">13</span> == <span class="number">0</span>);&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">它提供了一种有用的服务，对使用函数谓词的STL算法来说尤其如此。</span><br><span class="line"></span><br><span class="line">### <span class="number">4.1</span> 函数指针，函数符(仿函数)和Lambda</span><br><span class="line"></span><br><span class="line">出于方便的考虑，我们把函数指针，函数符，lambda统称为函数对象。</span><br><span class="line"></span><br><span class="line">假设要生成一个随机整数列表，并判断其中有多少个整数可以被<span class="number">3</span>整出，多少个被<span class="number">13</span>整除</span><br><span class="line"></span><br><span class="line">一种方案是使用<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;存储数字，并使用STL算法generate()在其中填充随机数：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(<span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">std</span>::generate(numbers.begin(), numbers.end(), <span class="built_in">std</span>::rand)</span><br></pre></td></tr></table></figure>
<p>上述示例中，该函数对象是一个指向标准函数rand()的指针。</p>
<p>通过使用算法count_if()，很容易计算出有多少个元素被3整除。与函数generate()一样，前两个参数指定区间，最后一个应该是返回true或者false的函数对象。函数count_if()计算这样的元素数，即它使得制定的函数对象返回true。为判断元素是否能被3整除，可使用下面的定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>同样可以定义判断是否能被13整除的函数f13(int x)。之后便可以计算符合条件的元素个数了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count3 = <span class="built_in">std</span>::count_if(numbers.begin(), numbers.end(), f3);</span><br><span class="line"><span class="keyword">int</span> count13 = <span class="built_in">std</span>::count_if(numbers.begin(), numbers.end(), f13);</span><br></pre></td></tr></table></figure>
<p>下面使用仿函数来完成这个任务，仿函数的优点之一是，可以使用同一个函数符来完成这两种计数任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f_mod</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dv;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    f_mod(<span class="keyword">int</span> d = <span class="number">1</span>) : dv(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x % dv == <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(<span class="number">1000</span>);</span><br><span class="line">    generate(arr.begin(), arr.end(), rand);</span><br><span class="line">    <span class="function">f_mod <span class="title">obj</span><span class="params">(<span class="number">3</span>)</span></span>;	<span class="comment">// f_mod.dv set to 3</span></span><br><span class="line">    <span class="keyword">bool</span> is_div_by_3 = obj(<span class="number">7</span>);	<span class="comment">// same as obj.operator()(7)</span></span><br><span class="line">    <span class="keyword">int</span> count3 = count_if(arr.begin(), arr.end(), f_mod(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>f_mod(3)创建一个对象，它存储了值3，而count_if()使用该对象来调用operator()()，并将参数x设置为numbers的一个元素。要计算多少个数字被13整除，只需要将第三个参数设置为f_mod(13)即可。</p>
<p>最后看看Lamdba的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count3 = count_if(arr.begin(), arr.end(),</span><br><span class="line">             [](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;&#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count3 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>也就是说，使用整个Lamdba表达式替换函数指针或函数符构造函数。</p>
<p>需要注意的是，仅当lambda完全由一条返回语句组成时，自动类型推断才管用；否则，需要使用新增的返回类型后置语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">double</span> x) -&gt; <span class="keyword">double</span> &#123;<span class="keyword">int</span> y = x; <span class="keyword">return</span> x - y;&#125; <span class="comment">// return type is double</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-为何使用Lamdba"><a href="#4-2-为何使用Lamdba" class="headerlink" title="4.2 为何使用Lamdba"></a>4.2 为何使用Lamdba</h3><p>距离、简洁、效率、功能。</p>
<p>Lambda可以被指定名称，并且可以像使用常规函数一样使用有名称的Lamdba</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod3 = [](<span class="keyword">int</span> x) &#123;<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> count3 = count_if(arr.begin(), arr.end(), mod3);</span><br><span class="line"><span class="keyword">bool</span> result = mod3(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="4-3-Lamdba额外功能"><a href="#4-3-Lamdba额外功能" class="headerlink" title="4.3 Lamdba额外功能"></a>4.3 Lamdba额外功能</h3><p>Lamdba可以访问作用域内的任何动态变量；要捕获要使用的变量，可将其名称放在中括号内。若只指定了变量名，如<code>[z]</code>，将按值访问变量；若在名称前加上<code>&amp;</code>，则按 引用访问变量。</p>
<p><code>[&amp;]</code>可以按引用访问所有动态变量</p>
<p><code>[=]</code>可以按值访问所有动态变量</p>
<p><code>[&amp;, ted]</code>可以按引用访问除了ted以外所有变量，ted按值访问</p>
<p><code>[=, ted]</code>可以按值访问除了ted以外所有变量，ted按引用访问</p>
<h2 id="五、可变参数模板"><a href="#五、可变参数模板" class="headerlink" title="五、可变参数模板"></a>五、可变参数模板</h2><p>可变参数模板可以创建接受可变数量的参数模板函数。</p>
<p>创建可变参数模板，需要如下几点：</p>
<ul>
<li>模板参数包</li>
<li>函数参数包</li>
<li>展开参数包</li>
<li>递归</li>
</ul>
<p>示例函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">show_list</span>(<span class="title">const</span> <span class="title">T</span> &amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">show_list</span>(<span class="title">const</span> <span class="title">T</span> &amp; <span class="title">value</span>, <span class="title">const</span> <span class="title">Args</span> &amp;... <span class="title">args</span>) &#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    show_list(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1.2341234</span>;</span><br><span class="line">    <span class="built_in">string</span> mr = <span class="string">"Mr. String"</span>;</span><br><span class="line">    show_list(n, x);</span><br><span class="line">    show_list(x * x, <span class="string">'!'</span>, <span class="number">7</span>, mr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>, <span class="number">1.23412</span></span><br><span class="line"><span class="number">1.52306</span>, !, <span class="number">7</span>, Mr. String</span><br></pre></td></tr></table></figure>
<h2 id="六、其他新增的功能"><a href="#六、其他新增的功能" class="headerlink" title="六、其他新增的功能"></a>六、其他新增的功能</h2><p>C++11添加了很多功能，其他的大致如下</p>
<ul>
<li>并行编程</li>
<li>随机函数库</li>
<li>低级编程</li>
<li>元编程支持</li>
<li>Boost</li>
<li>…</li>
</ul>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a>.</p>
</blockquote>

      
    </div>
    
    
    

    <div>
  		
    		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">本文结束------<i class="fa fa-pagelines"></i>------感谢阅读</div>
    
</div>

  		
	</div>

    

    

    
      <div>
        <div class="post-copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2019/07/18/2019-07-18-Talk-About-C-11-md/">C++11 New Feature</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Knives 的个人博客">Knives</a></p>
  <p><span>发布时间:</span>2019年07月18日 - 16:07</p>
  <p><span>原始链接:</span><a href="/2019/07/18/2019-07-18-Talk-About-C-11-md/" title="C++11 New Feature">http://knivezee.site/2019/07/18/2019-07-18-Talk-About-C-11-md/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://knivezee.site/2019/07/18/2019-07-18-Talk-About-C-11-md/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
      $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
        });
    });  
</script>
      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/language/" <i="" class="fa fa-tag"> language</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/27/2019-03-27-Morris/" rel="next" title="Morris Traversal">
                <i class="fa fa-chevron-left"></i> Morris Traversal
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://pj5mfieap.bkt.clouddn.com/avatar.jpg" alt="Knives">
            
              <p class="site-author-name" itemprop="name">Knives</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

			<!--my custom code begin-->
			<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
			<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.5.0/velocity.min.js"></script>
			<script type="text/javascript">
			  $("#sidebar").hover(function(){
				$("#mydivshow").velocity('stop').velocity({opacity: 1});
			  },function(){
				$("#mydivshow").velocity('stop').velocity({opacity: 0});
			  });
			</script>
			<div id="mydivshow" class="mydivshow">
			<!--my custom code end-->
			
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/kniveszee" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:kniveszee@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://weibo.com/kniveszee" target="_blank" title="微博">
                    
                      <i class="fa fa-fw fa-weibo"></i>微博</a>
                </span>
              
            
          </div>

          
          

          
          

          <div id="player1" class="aplayer"></div>
<script src="/js/src/APlayer.min.js"></script>
<script type="text/javascript">
var ap = new APlayer({
    element: document.getElementById('player1'),                       // Optional, player element
    narrow: false,                                                     // Optional, narrow style
    autoplay: false,                                                    // Optional, autoplay song(s), not supported by mobile browsers
    showlrc: 0,                                                        // Optional, show lrc, can be 0, 1, 2, see: ###With lrc
    mutex: true,                                                       // Optional, pause other players when this player playing
    theme: '#e6d0b2',                                                  // Optional, theme color, default: #b7daff
    mode: 'random',                                                    // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`
    preload: 'metadata',                                               // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'
    listmaxheight: '513px',                                             // Optional, max height of play list
    music: {                                                           // Required, music info, see: ###With playlist
        title: 'Uncharted',                                          // Required, music title
        author: 'Jeremy Lim',                          // Required, music author
        url: 'http://pj5mfieap.bkt.clouddn.com/Jeremy%20Lim%20-%20Uncharted%20%28Original%20Mix%29.mp3',  // Required, music url
        pic: 'http://pj5mfieap.bkt.clouddn.com/IMG_7714.JPG',  // Optional, music picture
    }
});
</script>
        </div>
		<!--my custom code begin-->
		</div>
		<!--my custom code end-->
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、-C-11的新功能"><span class="nav-number">1.</span> <span class="nav-text">一、 C++11的新功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-新类型"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 新类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-初始化列表语法"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 初始化列表语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-声明"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-智能指针"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-异常规范修改"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 异常规范修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-对类的修改"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 对类的修改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-显示转换运算符"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1 显示转换运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-类内成员初始化"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2 类内成员初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-模板和STL方面的修改"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 模板和STL方面的修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、-移动语义和右值引用"><span class="nav-number">2.</span> <span class="nav-text">二、 移动语义和右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-为什么需要移动语义"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 为什么需要移动语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-移动构造函数解析"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 移动构造函数解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-赋值"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-强制移动"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 强制移动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-std-move-原理"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 std::move() 原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、-新的类功能"><span class="nav-number">3.</span> <span class="nav-text">三、 新的类功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-特殊的成员函数"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 特殊的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-默认的方法和禁用的方法"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 默认的方法和禁用的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-委托构造函数"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 委托构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-继承构造函数，override和final"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 继承构造函数，override和final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Lamdba"><span class="nav-number">4.</span> <span class="nav-text">四、Lamdba</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-为何使用Lamdba"><span class="nav-number">4.1.</span> <span class="nav-text">4.2 为何使用Lamdba</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Lamdba额外功能"><span class="nav-number">4.2.</span> <span class="nav-text">4.3 Lamdba额外功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、可变参数模板"><span class="nav-number">5.</span> <span class="nav-text">五、可变参数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、其他新增的功能"><span class="nav-number">6.</span> <span class="nav-text">六、其他新增的功能</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Knives</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">48.6k</span>
  
</div>






<!--
  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div>
-->



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>




  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.3"></script>


  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.3"></script>


  <script src="/js/src/Aplayer-Controler.js"></script>
<div id="AP-controler"></div>
<script type="text/javascript">
var myapc=new APlayer_Controler({
		APC_dom:$('#AP-controler'),
		aplayer:ap, //此为绑定的aplayer对象
		attach_right:false,
		position:{top:'300px',bottom:''},
		fixed:true,
		btn_width:100,
		btn_height:120,
		img_src:['http://oty1v077k.bkt.clouddn.com/bukagirl.jpg',
				'http://oty1v077k.bkt.clouddn.com/pentigirl.jpg'],
		img_style:{repeat:'no-repeat',position:'center',size:'contain'},
		ctrls_color:'rgba(173,255,47,0.8)',
		ctrls_hover_color:'rgba(255,140,0,0.7)',
		tips_on:true,
		tips_width:140,
		tips_height:25,
		tips_color:'rgba(255,255,255,0.6)',
		tips_content:{},
		timeout:30
	});
</script>
  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<!-- 页面点击小红心 -->

<script type="text/javascript" src="/js/src/love.js"></script>





  <scripttype="text javascript"color="255,0,0" opacity="0.5" count="10" src="/lib/canvas-nest/canvas-nest.min.js">


</scripttype="text></body>
</html>
